Return-Path: <owner-linux-mm@kvack.org>
Received: from mail-wm0-f72.google.com (mail-wm0-f72.google.com [74.125.82.72])
	by kanga.kvack.org (Postfix) with ESMTP id BB8DC6B0388
	for <linux-mm@kvack.org>; Mon, 20 Mar 2017 16:11:12 -0400 (EDT)
Received: by mail-wm0-f72.google.com with SMTP id g8so18361272wmg.7
        for <linux-mm@kvack.org>; Mon, 20 Mar 2017 13:11:12 -0700 (PDT)
Received: from mail-wr0-x243.google.com (mail-wr0-x243.google.com. [2a00:1450:400c:c0c::243])
        by mx.google.com with ESMTPS id m196si16611938wmg.8.2017.03.20.13.11.10
        for <linux-mm@kvack.org>
        (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
        Mon, 20 Mar 2017 13:11:10 -0700 (PDT)
Received: by mail-wr0-x243.google.com with SMTP id l37so19729053wrc.3
        for <linux-mm@kvack.org>; Mon, 20 Mar 2017 13:11:10 -0700 (PDT)
Subject: Review request: draft ioctl_userfaultfd(2) manual page
References: <487b2c79-f99b-6d0f-2412-aa75cde65569@gmail.com>
From: "Michael Kerrisk (man-pages)" <mtk.manpages@gmail.com>
Message-ID: <9af29fc6-dce2-f729-0f07-a0bfcc6c3587@gmail.com>
Date: Mon, 20 Mar 2017 21:11:07 +0100
MIME-Version: 1.0
In-Reply-To: <487b2c79-f99b-6d0f-2412-aa75cde65569@gmail.com>
Content-Type: multipart/mixed;
 boundary="------------29120CE7722110A80A19B3CA"
Sender: owner-linux-mm@kvack.org
List-ID: <linux-mm.kvack.org>
To: Andrea Arcangeli <aarcange@redhat.com>, Mike Rapoport <rppt@linux.vnet.ibm.com>
Cc: mtk.manpages@gmail.com, lkml <linux-kernel@vger.kernel.org>, "linux-mm@kvack.org" <linux-mm@kvack.org>, linux-man <linux-man@vger.kernel.org>

This is a multi-part message in MIME format.
--------------29120CE7722110A80A19B3CA
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: 8bit

Hello Andrea, Mike, and all,

Mike: here's the split out page that describes the 
userfaultfd ioctl() operations.

I'd like to get review input, especially from you and
Andrea, but also anyone else, for the current version
of this page, which includes quite a few FIXMEs to be
sorted.

I've shown the rendered version of the page below. 
The groff source is attached, and can also be found
at the branch here:

https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/log/?h=draft_userfaultfd

The new ioctl_userfaultfd(2) page follows this mail.

Cheers,

Michael

NAME
       userfaultfd - create a file descriptor for handling page faults in user
       space

SYNOPSIS
       #include <sys/ioctl.h>

       int ioctl(int fd, int cmd, ...);

DESCRIPTION
       Various ioctl(2) operations can be performed on  a  userfaultfd  object
       (created by a call to userfaultfd(2)) using calls of the form:

           ioctl(fd, cmd, argp);

       In  the  above,  fd  is  a  file  descriptor referring to a userfaultfd
       object, cmd is one of the commands listed below, and argp is a  pointer
       to a data structure that is specific to cmd.

       The  various  ioctl(2) operations are described below.  The UFFDIO_API,
       UFFDIO_REGISTER, and UFFDIO_UNREGISTER operations are used to configure
       userfaultfd behavior.  These operations allow the caller to choose what
       features will be enabled and what kinds of events will be delivered  to
       the application.  The remaining operations are range operations.  These
       operations enable the calling application to resolve page-fault  events
       in a consistent way.


       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??FIXME                                                a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??Above: What does "consistent" mean?                  a??
       a??                                                     a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??

   UFFDIO_API
       (Since Linux 4.3.)  Enable operation of the userfaultfd and perform API
       handshake.  The argp argument is a pointer to a  uffdio_api  structure,
       defined as:

           struct uffdio_api {
               __u64 api;        /* Requested API version (input) */
               __u64 features;   /* Must be zero */
               __u64 ioctls;     /* Available ioctl() operations (output) */
           };

       The  api  field  denotes  the API version requested by the application.
       Before the call, the features field must be initialized to zero.


       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??FIXME                                                a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??Above: Why must the 'features' field be  initialized a??
       a??to zero?                                             a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??

       The  kernel verifies that it can support the requested API version, and
       sets the features and ioctls fields to bit masks representing  all  the
       available features and the generic ioctl(2) operations available.  Cura??
       rently, zero (i.e., no feature bits) is placed in the  features  field.
       The returned ioctls field can contain the following bits:


       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??FIXME                                                a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??This  user-space  API  seems not fully polished. Why a??
       a??are there not constants defined for each of the bit- a??
       a??mask values listed below?                            a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??

       1 << _UFFDIO_API
              The UFFDIO_API operation is supported.

       1 << _UFFDIO_REGISTER
              The UFFDIO_REGISTER operation is supported.

       1 << _UFFDIO_UNREGISTER
              The UFFDIO_UNREGISTER operation is supported.


              a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
              a??FIXME                                                a??
              a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
              a??Is  the above description of the 'ioctls' field cora?? a??
              a??rect?  Does more need to be said?                    a??
              a??                                                     a??
              a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??

       This ioctl(2) operation returns 0 on success.  On error, -1 is returned
       and  errno  is set to indicate the cause of the error.  Possible errors
       include:


       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??FIXME                                                a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??Is the following error list correct?                 a??
       a??                                                     a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??

       EINVAL The userfaultfd has already been  enabled  by  a  previous  UFFa??
              DIO_API operation.

       EINVAL The  API  version requested in the api field is not supported by
              this kernel, or the features field was not zero.


              a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
              a??FIXME                                                a??
              a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
              a??In the above error case, the  returned  'uffdio_api' a??
              a??structure  zeroed out. Why is this done? This should a??
              a??be explained in the manual page.                     a??
              a??                                                     a??
              a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??

   UFFDIO_REGISTER
       (Since Linux 4.3.)  Register a memory  address  range  with  the  usera??
       faultfd  object.   The  argp argument is a pointer to a uffdio_register
       structure, defined as:

           struct uffdio_range {
               __u64 start;    /* Start of range */
               __u64 len;      /* Length of rnage (bytes) */
           };

           struct uffdio_register {
               struct uffdio_range range;
               __u64 mode;     /* Desired mode of operation (input) */
               __u64 ioctls;   /* Available ioctl() operations (output) */
           };


       The range field defines a memory range starting at start and continuing
       for len bytes that should be handled by the userfaultfd.

       The  mode  field  defines the mode of operation desired for this memory
       region.  The following values may be bitwise  ORed  to  set  the  usera??
       faultfd mode for the specified range:

       UFFDIO_REGISTER_MODE_MISSING
              Track page faults on missing pages.

       UFFDIO_REGISTER_MODE_WP
              Track page faults on write-protected pages.

       Currently, the only supported mode is UFFDIO_REGISTER_MODE_MISSING.

       If the operation is successful, the kernel modifies the ioctls bit-mask
       field to indicate which ioctl(2) operations are available for the speca??
       ified range.  This returned bit mask is as for UFFDIO_API.

       This ioctl(2) operation returns 0 on success.  On error, -1 is returned
       and errno is set to indicate the cause of the error.   Possible  errors
       include:


       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??FIXME                                                a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??Is the following error list correct?                 a??
       a??                                                     a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??

       EBUSY  A  mapping  in  the  specified  range is registered with another
              userfaultfd object.

       EINVAL An invalid or unsupported bit was specified in the  mode  field;
              or the mode field was zero.

       EINVAL There is no mapping in the specified address range.

       EINVAL range.start  or  range.len  is not a multiple of the system page
              size; or, range.len is  zero;  or  these  fields  are  otherwise
              invalid.

       EINVAL There as an incompatible mapping in the specified address range.


              a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
              a??FIXME                                                a??
              a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
              a??Above: What does "incompatible" mean?                a??
              a??                                                     a??
              a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??

   UFFDIO_UNREGISTER
       (Since Linux 4.3.)  Unregister a memory address range from userfaultfd.
       The address range to unregister is specified in the uffdio_range struca??
       ture pointed to by argp.

       This ioctl(2) operation returns 0 on success.  On error, -1 is returned
       and errno is set to indicate the cause of the error.   Possible  errors
       include:

       EINVAL Either  the  start or the len field of the ufdio_range structure
              was not a multiple of the system page size; or the len field was
              zero; or these fields were otherwise invalid.

       EINVAL There as an incompatible mapping in the specified address range.


              a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
              a??FIXME                                                a??
              a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
              a??Above: What does "incompatible" mean?                a??
              a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??

       EINVAL There was no mapping in the specified address range.

   UFFDIO_COPY
       (Since  Linux 4.3.)  Atomically copy a continuous memory chunk into the
       userfault registered range and optionally wake up the  blocked  thread.
       The  source  and  destination addresses and the number of bytes to copy
       are specified by the src, dst, and len fields of the uffdio_copy struca??
       ture pointed to by argp:

           struct uffdio_copy {
               __u64 dst;    /* Source of copy */
               __u64 src;    /* Destinate of copy */
               __u64 len;    /* Number of bytes to copy */
               __u64 mode;   /* Flags controlling behavior of copy */
               __s64 copy;   /* Number of bytes copied, or negated error */
           };

       The  following value may be bitwise ORed in mode to change the behavior
       of the UFFDIO_COPY operation:

       UFFDIO_COPY_MODE_DONTWAKE
              Do not wake up the thread that waits for page-fault resolution

       The copy field is used by the kernel to return the number of bytes that
       was actually copied, or an error (a negated errno-style value).


       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??FIXME                                                a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??Above:  Why is the 'copy' field used to return error a??
       a??values?  This should  be  explained  in  the  manual a??
       a??page.                                                a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       If  the  value returned in copy doesn't match the value that was specia??
       fied in len, the operation fails with the error EAGAIN.  The copy field
       is output-only; it is not read by the UFFDIO_COPY operation.

       This ioctl(2) operation returns 0 on success.  In this case, the entire
       area was copied.  On error, -1 is returned and errno is set to indicate
       the cause of the error.  Possible errors include:

       EAGAIN The number of bytes copied (i.e., the value returned in the copy
              field) does not equal the value that was specified  in  the  len
              field.

       EINVAL Either dst or len was not a multiple of the system page size, or
              the range specified by src and len or dst and len was invalid.

       EINVAL An invalid bit was specified in the mode field.

   UFFDIO_ZEROPAGE
       (Since Linux 4.3.)  Zero out  a  memory  range  registered  with  usera??
       faultfd.   The  requested  range is specified by the range field of the
       uffdio_zeropage structure pointed to by argp:

           struct uffdio_zeropage {
               struct uffdio_range range;
               __u64 mode;     /* Flags controlling behavior of copy */
               __s64 zeropage; /* Number of bytes zeroed, or negated error */
           };

       The following value may be bitwise ORed in mode to change the  behavior
       of the UFFDIO_ZERO operation:

       UFFDIO_ZEROPAGE_MODE_DONTWAKE
              Do not wake up the thread that waits for page-fault resolution.

       The  zeropage field is used by the kernel to return the number of bytes
       that was actually zeroed, or an  error  in  the  same  manner  as  UFFa??
       DIO_COPY.


       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??FIXME                                                a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??Why  is  the  'zeropage'  field used to return error a??
       a??values?  This should  be  explained  in  the  manual a??
       a??page.                                                a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       If  the  value  returned  in the zeropage field doesn't match the value
       that was specified in range.len, the operation  fails  with  the  error
       EAGAIN.   The zeropage field is output-only; it is not read by the UFFa??
       DIO_ZERO operation.

       This ioctl(2) operation returns 0 on success.  In this case, the entire
       area was zeroed.  On error, -1 is returned and errno is set to indicate
       the cause of the error.  Possible errors include:

       EAGAIN The number of bytes zeroed (i.e.,  the  value  returned  in  the
              zeropage  field)  does not equal the value that was specified in
              the range.len field.

       EINVAL Either range.start or range.len was not a multiple of the system
              page  size;  or  range.len  was zero; or the range specified was
              invalid.

       EINVAL An invalid bit was specified in the mode field.

   UFFDIO_WAKE
       (Since Linux 4.3.)  Wake up the thread waiting for  page-fault  resolua??
       tion  on  a  specified  memory  address  range.  The argp argument is a
       pointer to a uffdio_range structure (shown above)  that  specifies  the
       address range.


       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??FIXME                                                a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??
       a??Need more detail here. How is the UFFDIO_WAKE operaa?? a??
       a??tion used?                                           a??
       a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??a??

       This ioctl(2) operation returns 0 on success.  On error, -1 is returned
       and  errno  is set to indicate the cause of the error.  Possible errors
       include:

       EINVAL The start or the len field of the ufdio_range structure was  not
              a  multiple  of  the  system  page size; or len was zero; or the
              specified range was otherwise invalid.

RETURN VALUE
       See descriptions of the individual operations, above.

ERRORS
       See descriptions of the individual operations, above.  In addition, the
       following  general errors can occur for all of the operations described
       above:

       EFAULT argp does not point to a valid memory address.

       EINVAL (For all operations except UFFDIO_API.)  The userfaultfd  object
              has not yet been enabled (via the UFFDIO_API operation).

CONFORMING TO
       These ioctl(2) operations are Linux-specific.

EXAMPLE
       See userfaultfd(2).

SEE ALSO
       ioctl(2), mmap(2), userfaultfd(2)

       Documentation/vm/userfaultfd.txt in the Linux kernel source tree


--------------29120CE7722110A80A19B3CA
Content-Type: application/x-troff-man;
 name="ioctl_userfaultfd.2"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
 filename="ioctl_userfaultfd.2"

.\" Copyright (c) 2016, IBM Corporation.
.\" Written by Mike Rapoport <rppt@linux.vnet.ibm.com>
.\" and Copyright (C) 2016 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\"
.TH IOCTL_USERFAULTFD 2 2016-12-12 "Linux" "Linux Programmer's Manual"
.SH NAME
userfaultfd \- create a file descriptor for handling page faults in user
space
.SH SYNOPSIS
.nf
.B #include <sys/ioctl.h>

.BI "int ioctl(int " fd ", int " cmd ", ...);"
.fi
.SH DESCRIPTION
Various
.BR ioctl (2)
operations can be performed on a userfaultfd object (created by a call to
.BR userfaultfd (2))
using calls of the form:

    ioctl(fd, cmd, argp);

In the above,
.I fd
is a file descriptor referring to a userfaultfd object,
.I cmd
is one of the commands listed below, and
.I argp
is a pointer to a data structure that is specific to
.IR cmd .

The various
.BR ioctl (2)
operations are described below.
The
.BR UFFDIO_API,
.BR UFFDIO_REGISTER ,
and
.BR UFFDIO_UNREGISTER
operations are used to
.I configure
userfaultfd behavior.
These operations allow the caller to choose what features will be enabled and
what kinds of events will be delivered to the application.
The remaining operations are
.IR range
operations.
These operations enable the calling application to resolve page-fault
events in a consistent way.
.\" FIXME Above: What does "consistent" mean?
.\"
.SS UFFDIO_API
(Since Linux 4.3.)
Enable operation of the userfaultfd and perform API handshake.
The
.I argp
argument is a pointer to a
.IR uffdio_api
structure, defined as:
.in +4n
.nf

struct uffdio_api {
    __u64 api;        /* Requested API version (input) */
    __u64 features;   /* Must be zero */
    __u64 ioctls;     /* Available ioctl() operations (output) */
};

.fi
.in
The
.I api
field denotes the API version requested by the application.
Before the call, the
.I features
field must be initialized to zero.
.\" FIXME Above: Why must the 'features' field be initialized to zero?

The kernel verifies that it can support the requested API version,
and sets the
.I features
and
.I ioctls
fields to bit masks representing all the available features and the generic
.BR ioctl (2)
operations available.
Currently, zero (i.e., no feature bits) is placed in the
.I features
field.
The returned
.I ioctls
field can contain the following bits:
.\" FIXME This user-space API seems not fully polished. Why are there
.\" not constants defined for each of the bit-mask values listed below?
.TP
.B 1 << _UFFDIO_API
The
.B UFFDIO_API
operation is supported.
.TP
.B 1 << _UFFDIO_REGISTER
The
.B UFFDIO_REGISTER
operation is supported.
.TP
.B 1 << _UFFDIO_UNREGISTER
The
.B UFFDIO_UNREGISTER
operation is supported.
.\" FIXME Is the above description of the 'ioctls' field correct?
.\" Does more need to be said?
.\"
.PP
This
.BR ioctl (2)
operation returns 0 on success.
On error, \-1 is returned and
.I errno
is set to indicate the cause of the error.
Possible errors include:
.\" FIXME Is the following error list correct?
.\"
.TP
.B EINVAL
The userfaultfd has already been enabled by a previous
.BR UFFDIO_API
operation.
.TP
.B EINVAL
The API version requested in the
.I api
field is not supported by this kernel, or the
.I features
field was not zero.
.\" FIXME In the above error case, the returned 'uffdio_api' structure
.\" zeroed out. Why is this done? This should be explained in the manual page.
.\"
.SS UFFDIO_REGISTER
(Since Linux 4.3.)
Register a memory address range with the userfaultfd object.
The
.I argp
argument is a pointer to a
.I uffdio_register
structure, defined as:
.in +4n
.nf

struct uffdio_range {
    __u64 start;    /* Start of range */
    __u64 len;      /* Length of rnage (bytes) */
};

struct uffdio_register {
    struct uffdio_range range;
    __u64 mode;     /* Desired mode of operation (input) */
    __u64 ioctls;   /* Available ioctl() operations (output) */
};

.fi
.in

The
.I range
field defines a memory range starting at
.I start
and continuing for
.I len
bytes that should be handled by the userfaultfd.

The
.I mode
field defines the mode of operation desired for this memory region.
The following values may be bitwise ORed to set the userfaultfd mode for
the specified range:
.TP
.B UFFDIO_REGISTER_MODE_MISSING
Track page faults on missing pages.
.TP
.B UFFDIO_REGISTER_MODE_WP
Track page faults on write-protected pages.
.PP
Currently, the only supported mode is
.BR UFFDIO_REGISTER_MODE_MISSING .
.PP
If the operation is successful, the kernel modifies the
.I ioctls
bit-mask field to indicate which
.BR ioctl (2)
operations are available for the specified range.
This returned bit mask is as for
.BR UFFDIO_API .

This
.BR ioctl (2)
operation returns 0 on success.
On error, \-1 is returned and
.I errno
is set to indicate the cause of the error.
Possible errors include:
.\" FIXME Is the following error list correct?
.\"
.TP
.B EBUSY
A mapping in the specified range is registered with another
userfaultfd object.
.TP
.B EINVAL
An invalid or unsupported bit was specified in the
.I mode
field; or the
.I mode
field was zero.
.TP
.B EINVAL
There is no mapping in the specified address range.
.TP
.B EINVAL
.I range.start
or
.I range.len
is not a multiple of the system page size; or,
.I range.len
is zero; or these fields are otherwise invalid.
.TP
.B EINVAL
There as an incompatible mapping in the specified address range.
.\" FIXME Above: What does "incompatible" mean?
.\"
.SS UFFDIO_UNREGISTER
(Since Linux 4.3.)
Unregister a memory address range from userfaultfd.
The address range to unregister is specified in the
.IR uffdio_range
structure pointed to by
.IR argp .

This
.BR ioctl (2)
operation returns 0 on success.
On error, \-1 is returned and
.I errno
is set to indicate the cause of the error.
Possible errors include:
.TP
.B EINVAL
Either the
.I start
or the
.I len
field of the
.I ufdio_range
structure was not a multiple of the system page size; or the
.I len
field was zero; or these fields were otherwise invalid.
.TP
.B EINVAL
There as an incompatible mapping in the specified address range.
.\" FIXME Above: What does "incompatible" mean?
.TP
.B EINVAL
There was no mapping in the specified address range.
.\"
.SS UFFDIO_COPY
(Since Linux 4.3.)
Atomically copy a continuous memory chunk into the userfault registered
range and optionally wake up the blocked thread.
The source and destination addresses and the number of bytes to copy are
specified by the
.IR src ", " dst ", and " len
fields of the
.I uffdio_copy
structure pointed to by
.IR argp :

.in +4n
.nf
struct uffdio_copy {
    __u64 dst;    /* Source of copy */
    __u64 src;    /* Destinate of copy */
    __u64 len;    /* Number of bytes to copy */
    __u64 mode;   /* Flags controlling behavior of copy */
    __s64 copy;   /* Number of bytes copied, or negated error */
};
.fi
.in
.PP
The following value may be bitwise ORed in
.IR mode
to change the behavior of the
.B UFFDIO_COPY
operation:
.TP
.B UFFDIO_COPY_MODE_DONTWAKE
Do not wake up the thread that waits for page-fault resolution
.PP
The
.I copy
field is used by the kernel to return the number of bytes
that was actually copied, or an error (a negated
.IR errno -style
value).
.\" FIXME Above: Why is the 'copy' field used to return error values?
.\" This should be explained in the manual page.
If the value returned in
.I copy
doesn't match the value that was specified in
.IR len ,
the operation fails with the error
.BR EAGAIN .
The
.I copy
field is output-only;
it is not read by the
.B UFFDIO_COPY
operation.

This
.BR ioctl (2)
operation returns 0 on success.
In this case, the entire area was copied.
On error, \-1 is returned and
.I errno
is set to indicate the cause of the error.
Possible errors include:
.TP
.B EAGAIN
The number of bytes copied (i.e., the value returned in the
.I copy
field)
does not equal the value that was specified in the
.I len
field.
.TP
.B EINVAL
Either
.I dst
or
.I len
was not a multiple of the system page size, or the range specified by
.IR src
and
.IR len
or
.IR dst
and
.IR len
was invalid.
.TP
.B EINVAL
An invalid bit was specified in the
.IR mode
field.
.\"
.SS UFFDIO_ZEROPAGE
(Since Linux 4.3.)
Zero out a memory range registered with userfaultfd.
The requested range is specified by the
.I range
field of the
.I uffdio_zeropage
structure pointed to by
.IR argp :

.in +4n
.nf
struct uffdio_zeropage {
    struct uffdio_range range;
    __u64 mode;     /* Flags controlling behavior of copy */
    __s64 zeropage; /* Number of bytes zeroed, or negated error */
};
.fi
.in
.PP
The following value may be bitwise ORed in
.IR mode
to change the behavior of the
.B UFFDIO_ZERO
operation:
.TP
.B UFFDIO_ZEROPAGE_MODE_DONTWAKE
Do not wake up the thread that waits for page-fault resolution.
.PP
The
.I zeropage
field is used by the kernel to return the number of bytes
that was actually zeroed,
or an error in the same manner as
.BR UFFDIO_COPY .
.\" FIXME Why is the 'zeropage' field used to return error values?
.\" This should be explained in the manual page.
If the value returned in the
.I zeropage
field doesn't match the value that was specified in
.IR range.len ,
the operation fails with the error
.BR EAGAIN .
The
.I zeropage
field is output-only;
it is not read by the
.B UFFDIO_ZERO
operation.

This
.BR ioctl (2)
operation returns 0 on success.
In this case, the entire area was zeroed.
On error, \-1 is returned and
.I errno
is set to indicate the cause of the error.
Possible errors include:
.TP
.B EAGAIN
The number of bytes zeroed (i.e., the value returned in the
.I zeropage
field)
does not equal the value that was specified in the
.I range.len
field.
.TP
.B EINVAL
Either
.I range.start
or
.I range.len
was not a multiple of the system page size; or
.I range.len
was zero; or the range specified was invalid.
.TP
.B EINVAL
An invalid bit was specified in the
.IR mode
field.
.\"
.SS UFFDIO_WAKE
(Since Linux 4.3.)
Wake up the thread waiting for page-fault resolution on
a specified memory address range.
The
.I argp
argument is a pointer to a
.I uffdio_range
structure (shown above) that specifies the address range.
.\" FIXME: Need more detail here. How is the UFFDIO_WAKE operation used?

This
.BR ioctl (2)
operation returns 0 on success.
On error, \-1 is returned and
.I errno
is set to indicate the cause of the error.
Possible errors include:
.TP
.B EINVAL
The
.I start
or the
.I len
field of the
.I ufdio_range
structure was not a multiple of the system page size; or
.I len
was zero; or the specified range was otherwise invalid.
.SH RETURN VALUE
See descriptions of the individual operations, above.
.SH ERRORS
See descriptions of the individual operations, above.
In addition, the following general errors can occur for all of the
operations described above:
.TP
.B EFAULT
.I argp
does not point to a valid memory address.
.TP
.B EINVAL
(For all operations except
.BR UFFDIO_API .)
The userfaultfd object has not yet been enabled (via the
.BR UFFDIO_API
operation).
.SH CONFORMING TO
These
.BR ioctl (2)
operations are Linux-specific.
.SH EXAMPLE
See
.BR userfaultfd (2).
.SH SEE ALSO
.BR ioctl (2),
.BR mmap (2),
.BR userfaultfd (2)

.IR Documentation/vm/userfaultfd.txt
in the Linux kernel source tree


--------------29120CE7722110A80A19B3CA--

--
To unsubscribe, send a message with 'unsubscribe linux-mm' in
the body to majordomo@kvack.org.  For more info on Linux MM,
see: http://www.linux-mm.org/ .
Don't email: <a href=mailto:"dont@kvack.org"> email@kvack.org </a>
